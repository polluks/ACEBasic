                    +--------------------------------+
                    | ACE Internal Calling Conventions|
                    +--------------------------------+

This document describes the internal calling conventions used by ACE for SUBs
and FUNCTIONs, including the CSLR (BASIC) and C conventions, and all SUB
modifier keywords.


Overview
--------
ACE implements two distinct calling conventions:

  Convention     Usage                   Parameters           Stack Cleanup
  ----------     -----                   ----------           -------------
  CSLR (BASIC)   ACE SUBs                Callee's stack       Automatic
  C              External/library funcs  Caller's stack       Caller cleans up

The return value is placed in a frame variable or D0 for CSLR, and always D0
for C convention.


CSLR Calling Convention
-----------------------
CSLR stands for "CLoSuRe" - the magic signature $434C5352 (ASCII "CLSR")
identifies functions using this convention.

Characteristics:

  - Parameters location: Stored in the callee's stack frame at negative
    offsets from SP
  - Multitasking safety: Caller calls Forbid() before pushing parameters;
    callee calls Permit() in prologue
  - Return value: Stored in frame variable (normal SUBs) or D0
    (EXTERNAL/INVOKABLE/CALLBACK)

Stack Layout (Caller's View):

        SP+0    -> Return Address
        SP-8    -> First parameter  (4-byte slot)
        SP-12   -> Second parameter (4-byte slot)
        SP-16   -> Third parameter  (4-byte slot)
        ...

Caller Code (load_params):

        ; Disable multitasking during parameter setup
        movea.l _AbsExecBase,a6
        jsr     _LVOForbid(a6)

        ; Store parameters at callee's stack offsets
        move.w  param1,-8(sp)        ; SHORT parameter
        move.l  param2,-12(sp)       ; LONG parameter

        ; Call the SUB
        jsr     _SUB_MyFunc

Callee Code (sub_params):

        _SUB_MyFunc:
            link    a5,#-24              ; Create frame (24 bytes local storage)

            ; Re-enable multitasking
            movea.l _AbsExecBase,a6
            jsr     _LVOPermit(a6)

            ; Load parameters from stack
            move.w  -8(sp),d0            ; Load SHORT param 1
            move.w  d0,-4(a5)            ; Store as local variable

            ... code ...

            move.l  result,-8(a5)        ; Store return value in frame
            unlk    a5
            rts


C Calling Convention
--------------------
Used for external functions, library calls, and indirect calls to unknown
function signatures.

Characteristics:

  - Parameters location: Pushed on caller's stack in reverse order
    (rightmost first)
  - Stack cleanup: Caller removes parameters after call
  - Return value: Always in register D0

Caller Code:

        ; Push parameters right-to-left
        move.l  param3,-(sp)         ; Push third param
        move.l  param2,-(sp)         ; Push second param
        move.l  param1,-(sp)         ; Push first param

        ; Call the function
        jsr     _ExternalFunc

        ; Caller cleans up stack
        add.l   #12,sp               ; Remove 3 LONGINTs (3 * 4 bytes)

        ; Return value is in D0
        move.l  d0,result


SUB Modifier Keywords
---------------------
ACE supports three mutually exclusive modifier keywords for SUBs: EXTERNAL,
INVOKABLE, and CALLBACK. A SUB without any modifier is a "normal" SUB.


Normal SUB (No Modifier)
------------------------

        SUB LONGINT Calculate(LONGINT x, LONGINT y)
            Calculate = x + y
        END SUB

Behavior:
  - Uses CSLR calling convention
  - Return value stored in frame variable at negative offset from A5
  - Can only be called directly (not suitable for closures)

Generated Code:

        _SUB_Calculate:
            link    a5,#-12
            ... code ...
            move.l  d0,-4(a5)        ; Return value in frame variable
            unlk    a5
            rts


EXTERNAL Modifier
-----------------

        SUB LONGINT AddNumbers(LONGINT a, LONGINT b) EXTERNAL

Purpose: Declares a SUB defined in another ACE module.

Behavior:
  - Uses CSLR calling convention
  - Return value in D0 (not frame variable)
  - Linkage resolved at link time via XREF mechanism
  - Internal "address" field set to extfunc (3004)

When to Use:
  - When calling SUBs from separately compiled modules
  - With EXTERNAL modulename declarations


INVOKABLE Modifier
------------------

        SUB LONGINT Double(LONGINT x) INVOKABLE
            Double = x * 2
        END SUB

Purpose: Optimizes SUB for use with BIND() and INVOKE.

Behavior:
  - Uses CSLR calling convention
  - Return value MUST be in D0 (not frame variable)
  - Can still be called directly like normal SUBs
  - Internal "address" field set to extfunc (3004)

When to Use:
  - SUB will be passed to BIND() to create closures
  - SUB will be passed as callback via ADDRESS parameter
  - Return value must be accessible through INVOKE

Why Needed: Frame variables at -X(a5) are not accessible to indirect callers
because the callee's A5 is different. Using D0 ensures the return value is
accessible.

Example Usage:

        SUB LONGINT Double(LONGINT x) INVOKABLE
            Double = x * 2
        END SUB

        closure& = BIND(@Double, 5)
        result& = INVOKE closure&()    ' Returns 10


CALLBACK Modifier
-----------------

        SUB LONGINT MyHook(ADDRESS hook, ADDRESS object, ADDRESS msg) CALLBACK
            ' Process hook call
            MyHook = 0  ' Return via D0
        END SUB

Purpose: Creates an Amiga Hook callback compatible with CallHookPkt().

Requirements:
  - Must have exactly 3 ADDRESS (LONGINT) parameters
  - Cannot be called from ACE code directly
  - Only invoked by external code via Hook mechanism

Register Parameter Mapping:

        Parameter 1 (hook)   <- A0 (Hook pointer)
        Parameter 2 (object) <- A2 (Object pointer)
        Parameter 3 (msg)    <- A1 (Message pointer)

Note: The A2, A1 order (not A1, A2) follows Amiga Hook convention.

Behavior:
  - Return value in D0
  - All registers saved/restored (MOVEM d1-d7/a0-a6)
  - Internal "address" field set to extfunc (3004)

Generated Code:

        _SUB_MyHook:
            movem.l d1-d7/a0-a6,-(sp)    ; Save all registers
            link    a5,#-16

            ; Map registers to parameters
            move.l  a0,-4(a5)             ; hook from A0
            move.l  a2,-8(a5)             ; object from A2
            move.l  a1,-12(a5)            ; msg from A1

            ... code ...

            move.l  result,d0             ; Return in D0
            unlk    a5
            movem.l (sp)+,d1-d7/a0-a6     ; Restore all registers
            rts


Return Value Handling
---------------------

  SUB Type             Return Location      How Caller Accesses
  --------             ---------------      -------------------
  Normal (frame)       Frame var -X(a5)     Via stack after return
  EXTERNAL             Register D0          Via stack pop
  INVOKABLE            Register D0          Via stack pop or INVOKE
  CALLBACK             Register D0          Via D0 after return
  Module SUB           Register D0          Via stack pop

The compiler determines the mechanism by checking the "address" field in the
symbol table: if address != extfunc, it's a normal SUB (return via frame
variable); otherwise it's EXTERNAL/INVOKABLE/CALLBACK (return in D0).


Runtime CLSR Detection
----------------------
When calling through a function pointer via INVOKE, the compiler generates
code to detect the calling convention at runtime:

        move.l  closure_addr,a2      ; Load function pointer
        cmp.l   #$434C5352,(a2)      ; Check for "CLSR" magic
        beq     _clsr_path           ; If CLSR, use BASIC calling

    ; --- C calling convention path ---
        move.l  param1,-(sp)         ; Push args right-to-left
        move.l  param2,-(sp)
        move.l  a2,a0
        jsr     (a0)                 ; Call
        add.l   #8,sp                ; Caller cleanup
        bra     _done

    ; --- CLSR path: BASIC calling convention ---
    _clsr_path:
        movea.l _AbsExecBase,a6
        jsr     _LVOForbid(a6)
        move.l  param1,-8(sp)        ; Store in callee frame
        move.l  param2,-12(sp)
        move.l  4(a2),a0             ; Function pointer at offset +4
        jsr     (a0)

    _done:
        move.l  d0,-(sp)             ; Push return value to stack


Address Field Encoding
----------------------
The "address" field in the SYM structure serves multiple purposes:

  Value              Meaning                 Usage
  -----              -------                 -----
  Negative number    Stack frame offset      Normal SUBs access locals via -X(a5)
  extfunc (3004)     External/special mark   EXTERNAL, CALLBACK, INVOKABLE, Module
  Positive number    Library function off    Shared library funcs offset from base


Module Considerations
---------------------
When compiling with -m (module mode), all SUBs automatically use D0 for
return values. This is necessary because modules cannot use normal A4-relative
addressing for the main program's frame.


Quick Reference
---------------

When to Use Each Modifier:

  Scenario                              Modifier
  --------                              --------
  Regular SUB called directly           None
  SUB in separate module                EXTERNAL
  SUB used with BIND()/INVOKE           INVOKABLE
  SUB called via Amiga Hook             CALLBACK


Calling Convention Decision Tree:

        Is it a library function?
          YES -> C convention (caller cleans stack, D0 return)
          NO  -> Is it an ACE SUB?
                   YES -> CSLR convention
                            Is address == extfunc?
                              YES -> Return in D0
                              NO  -> Return in frame variable
                   NO  -> C convention (runtime detection for INVOKE)


Implementation Files
--------------------
For reference, the relevant source files in the compiler:

  File                   Purpose
  ----                   -------
  src/ace/c/sub.c        load_params(), sub_params() - parameter passing
  src/ace/c/parse.c      SUB definition parsing, modifier detection
  src/ace/c/statement.c  SUB invocation, INVOKE statement
  src/ace/c/factor.c     Indirect function calls in expressions
  src/ace/c/assign.c     Return value storage
  src/ace/c/libfunc.c    C calling convention for library calls
  src/ace/c/acedef.h     Type definitions, extfunc constant
