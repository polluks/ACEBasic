# CALLBACK SUB Implementation State

## Spec Reference
specs/callback-sub-basic.txt

## Current Phase
Phase 8: Documentation - COMPLETE

## Phases Overview
- [x] Phase 1: Lexer changes (acedef.h, lexvar.c) - add CALLBACK keyword
- [x] Phase 2: Symbol definitions (acedef.h) - add is_callback flag to SYM struct
- [x] Phase 3: Parser changes (parse.c, lex.c) - handle CALLBACK in SUB parsing
- [x] Phase 4: Code generation (parse.c) - entry/exit code for CALLBACK SUBs
- [x] Phase 5: Address-of operator - verified @ works (no changes needed)
- [x] Phase 6: Error checking - prevent direct calls to CALLBACK SUBs
- [x] Phase 7: Unit testing - runner.rexx tests pass
- [x] Phase 7b: Integration testing - CallHookPkt tests pass
- [x] Phase 8: Documentation - ace.txt and ref.txt updated

## Phase 1 Details

### Files modified:
1. src/ace/c/acedef.h - Added `callbacksym` to enum (between bytesym and casesym)
2. src/ace/c/lexvar.c - Added "CALLBACK" to rword[] array (between "BYTE" and "CASE")

### Verification:
- [x] Build compiler successfully (2026-01-29)

## Phase 2 Details

### Files modified:
1. src/ace/c/acedef.h - Added `is_callback` BOOL field to SYM structure

### Verification:
- [x] Build compiler successfully (2026-01-29)

## Phase 3 Details

### Files modified:
1. src/ace/c/lex.c - Added error 84: "CALLBACK SUB must have exactly 3 ADDRESS parameters"
2. src/ace/c/parse.c - Added CALLBACK detection in block() function after EXTERNAL handling

### Changes in parse.c (after line 197):
- Detect `callbacksym` after parameter parsing
- Set `sub_ptr->is_callback = TRUE`
- Validate exactly 3 ADDRESS (longtype) parameters, error 84 if not
- Set `sub_ptr->address = extfunc` for D0 return value
- Make SUB externally visible (XDEF) for Hook.h_Entry

### Verification:
- [x] Build compiler successfully (2026-01-29)

## Phase 4 Details

### Files modified:
1. src/ace/c/parse.c - Added entry/exit code generation for CALLBACK SUBs

### Changes in parse.c:
- Added `CODE *sub_label_code;` variable declaration
- Save label code pointer before link for entry code insertion
- Initialize `sub_ptr->is_callback = FALSE` after sub_ptr assignment
- In CALLBACK block:
  - Insert `movem.l d1-d7/a0-a6,-(sp)` BEFORE link instruction using alloc_code
  - NOP out Permit code generated by sub_params (not needed for CALLBACK)
  - Generate parameter copies: `move.l a0,-4(a5)`, `move.l a2,-8(a5)`, `move.l a1,-12(a5)`
  - **Force return type to longtype** (`sub_ptr->type = longtype;`)
- At exit code: Add `movem.l (sp)+,d1-d7/a0-a6` after unlk for CALLBACK

### Generated assembly structure:
```asm
_SUB_name:
    movem.l d1-d7/a0-a6,-(sp)   ; Save all registers
    link    a5,#-12              ; Create local frame
    move.l  a0,-4(a5)            ; param 1: hook from A0
    move.l  a2,-8(a5)            ; param 2: object from A2
    move.l  a1,-12(a5)           ; param 3: message from A1
    ; ... function body ...
    move.l  <value>,d0           ; Return value in D0 (no SPFlt conversion)
_EXIT_SUB_name:
    unlk    a5
    movem.l (sp)+,d1-d7/a0-a6   ; Restore registers
    rts
```

### Verification:
- [x] Build compiler successfully on Amiga emulator (2026-01-29)
- [x] Test program compiles successfully
- [x] Generated assembly contains correct register save/restore
- [x] Generated assembly contains correct parameter copies (A0, A2, A1 order)
- [x] Permit code removed for CALLBACK SUBs
- [x] Return value correctly placed in D0 without SPFlt conversion (fixed 2026-01-29)

## Phase 5 Details

### Verification:
- [x] Created test case: verify/tests/cases/callback/callback-addressof.b
- [x] Compiled on Amiga emulator successfully (2026-01-29)
- [x] Generated assembly shows `pea _SUB_MYHOOK` for `@MyHook` expression

### Result:
No changes needed to compiler. The existing `address_of_object()` function in basfun.c (lines 1681-1686) already handles CALLBACK SUBs correctly because they use the same `_SUB_<name>` label naming convention as regular SUBs.

Generated assembly for `hookAddr& = @MyHook`:
```asm
pea	_SUB_MYHOOK
move.l	(sp)+,-8(a4)
```

## Phase 6 Details

### Files modified:
1. src/ace/c/lex.c - Added error 85: "CALLBACK SUB cannot be called from ACE code"
2. src/ace/c/statement.c - Added is_callback check for implicit and explicit CALL
3. src/ace/c/factor.c - Added is_callback check for calls in expression context

### Changes in statement.c:
- Line ~278: Check `sub_item->is_callback` before implicit SUB call
- Line ~503: Check `curr_item->is_callback` before explicit CALL command

### Changes in factor.c:
- Line ~286: Check `fact_item->is_callback` before SUB call in expression

### Test cases created:
- verify/tests/cases/errors/callback-direct-call.b (explicit CALL)
- verify/tests/cases/errors/callback-implicit-call.b (implicit call)
- verify/tests/cases/errors/callback-expr-call.b (expression context)

### Verification:
- [x] Build compiler successfully on Amiga emulator (2026-01-29)
- [x] Direct CALL produces error 85: "CALLBACK SUB cannot be called from ACE code"
- [x] Implicit call produces error 85
- [x] Expression call produces error 85

## Phase 7 Details (Unit Tests)

### Test organization:
- Added `callback` to runner.rexx categories list
- Moved error tests to `cases/errors/` directory

### Test files:
**cases/callback/** (compile-only tests):
- callback-basic.b - tests CALLBACK SUB assembly generation
- callback-addressof.b - tests @ operator with CALLBACK SUBs
- callback-param-test.b - integration test for parameter passing
- callback-register-test.b - integration test for register preservation

**cases/errors/** (expected failure tests):
- callback-direct-call.b - error 85 for explicit CALL
- callback-implicit-call.b - error 85 for implicit call
- callback-expr-call.b - error 85 for expression context call

### Verification:
- [x] runner.rexx callback category: 4 passed, 0 failed (2026-01-29)
- [x] runner.rexx errors category: 10 passed, 0 failed (includes 3 callback tests)

## Phase 7b Details (Integration Tests)

### Test files created:
1. **callback-param-test.b** - Parameter passing via CallHookPkt
   - Verifies hook pointer (A0) received correctly
   - Verifies h_Data can be read from hook structure
   - Verifies return value in D0

2. **callback-register-test.b** - Register preservation
   - Verifies caller's registers not corrupted after callback
   - Verifies callback can use many local variables
   - Verifies return value in D0

### Bug fix during integration testing:
- **Issue**: Return value was being converted to float via SPFlt
- **Cause**: CALLBACK SUB type defaulted to singletype (float)
- **Fix**: Added `sub_ptr->type = longtype;` in CALLBACK handling block (parse.c line 220)

### Verification:
- [x] Parameter test: PASS - h_Data (12345) received correctly via A0, return value (42) correct
- [x] Register test: PASS - All caller registers preserved, return value (1000) correct
- [x] All unit tests still pass after fix (2026-01-29)

## Phase 8 Details (Documentation)

### Files modified:
1. docs/ace.txt - Added "Callback SUBs for Amiga Hooks" section after "Memory Behaviour"
2. docs/ref.txt - Added CALLBACK keyword entry and updated SUB..END SUB with CALLBACK syntax

### Documentation added to ace.txt:
- CALLBACK SUB Syntax
- Hook Calling Convention (A0, A2, A1 register order)
- Getting the Callback Address (@ operator)
- Restrictions (cannot call from ACE, 3 ADDRESS params, no SHARED)
- Example: MUI Button Hook with Hook structure
- Accessing Hook Data via h_Data field

### Documentation added to ref.txt:
- CALLBACK keyword entry (alphabetical listing)
- SUB..END SUB CALLBACK syntax variant with full description

### Verification:
- [x] Documentation complete (2026-01-29)

## Implementation Complete

All phases of CALLBACK SUB implementation are complete:
1. Lexer, symbol, parser, and code generation changes
2. Error checking prevents direct calls from ACE code
3. Unit and integration tests pass
4. Documentation updated

## Notes
- CALLBACK keyword comes AFTER parameter list: `SUB Name(p1, p2, p3) CALLBACK`
- Similar to EXTERNAL keyword handling
- Parser changes are in parse.c, not sub.c (spec was slightly off on file location)
- Hook convention uses unusual register order: A0, A2, A1 (not A0, A1, A2)
- Return type forced to LONGINT to avoid float conversion issues
